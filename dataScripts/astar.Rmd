---
title: "path"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(plotly)
```

## import data 
```{r import_data}
read_as_df <- function(path, col_name) {
  df <- read.csv(path, header = FALSE) %>% data.frame()
  names(df) <- col_name
  return(df)
}

points <- read.csv("data/cpp_astar_path.csv")
points_pick_reg <- read.csv("data/cpp_reg_simplified.csv")
three_d_map <- read.csv("data/status.csv")
curve_points <- read.csv("data/cpp_smoothCurv.csv")

head(points)
head(points_pick_reg)
```

## visiualization of the path
Following section prints out the path as lines and no map information is demonstrated.
```{r plotly, include=FALSE, warning=FALSE}
print_points <- function(input_df){
  return (input_df %>% 
            plot_ly() %>% 
            add_paths(x = ~x, y = ~y, z = ~z))
}
```
Demonstration of path from astar:
```{r print_points, warning=FALSE}
print_points(points)
```
Demonstration of path after regression based selector:
```{r regression, warning=FALSE}
print_points(points_pick_reg)
```
Demonstration of path of smooth curve:
```{r curve, warning=FALSE}
print_points(curve_points)
```


## visiualization with searched areas and blocked areas.
Following section prints out the path and blocked areas.
Blocked areas are in the color of grey (#696969)
Searched areas are in the color of sky-blue (#66ccff)
path are in the color of red (#ff0000), the width of the path is extended to 10.
```{r plot_model, include=FALSE, warning=FALSE}
print_3D_model_path <- function(map_df, path_df, block_status = 1, searched_status = 2) {
  map_block <- map_df %>% filter(status == block_status)
  map_searched <- map_df %>% filter(status == searched_status)
  p <- plot_ly() %>%
  # draw blocked
  add_trace(type="scatter3d", mode = 'markers', ids = 'blocks',
            x = map_block$x, y = map_block$y, z = map_block$z, 
            marker = list(color = c('#696969'), 
                          symbol = 'square', size = '2', opacity = '0.5')) %>% 
  # draw searched
  add_trace(type="scatter3d", mode = 'markers', ids = 'blocks',
            x = map_searched$x, y = map_searched$y, z = map_searched$z, 
            marker = list(color = c('#66ccff'), 
                          symbol = 'square', size = '0.2', opacity = '1')) %>% 
  
  add_paths(x = path_df$x, y = path_df$y, z = path_df$z,
            line = list(width = 10, color = '#FF0000'))
  p
}
```
Map and non-smoothed path:
```{r print_model_reg}
print_3D_model_path(three_d_map, points_pick_reg)
```
Map and smoothed path:
```{r print_model_smooth}
print_3D_model_path(three_d_map, curve_points)
```

## v-t a-t j-t visualization.

In path smooth test, we performed the test with the following argument:
1. sample period: 0.01 s
2. max error: 0.08 m
3. begin speed: 0 m/s
4. end speed: 0 m/s

Functions needed:
```{r data processing}
find_dist_vec <- function(vec1, vec2){
  vec = vec2 - vec1
  return(sqrt(vec[1]^2 + vec[2]^2 + vec[3]^2))
}

find_dist_from_df <- function(df) {
  dist <- c(0)
  for(i in 2:nrow(df)){
    vec1 <- df[i-1,1:3] %>% as.matrix() %>% as.vector()
    vec2 <- df[i,1:3] %>% as.matrix() %>% as.vector()
    dist[i] <- find_dist_vec(vec1, vec2)
  }
  return(dist)
}

find_speed_from_distance <- function(distance_vec, timePeriod){
  return(distance_vec / timePeriod)
}

differential_with_time <- function(target, timePeriod){
  result <- c(0)
  for(i in 2:length(target)){
    result[i] <- (target[i] - target[i-1]) / timePeriod
  }
  return(result)
}


differentiate_df <- function(df, names, newNames, dt = 0.01){
  # 根据输入的列名选取数据
  data <- df %>% select(names)
  # 新建一个数据，使得第一行数据等于原本data的第一行
  data_move_down <- data.frame()
  data_move_down <- data[1,]
  # 复制data到data_move_down第一行之后。
  data_move_down <- data_move_down %>% rbind(data)
  # 保证data与data_move_down长度相同，方便做差
  data_move_down <- data_move_down[1:nrow(data),]
  # 两者做差，得到差分效果，并除以时间间隔
  data_difference <- (data - data_move_down) / dt
  # 把每个值都平方
  data_difference_next <- data_difference %>% sapply(function(v){return(v^2)}) %>% as.data.frame
  # 一列一列的值加起来变成新的一列
  data_difference$sum <- runif(nrow(data_difference_next), 0, 0)
  for(i in 1:length(names)){
    data_difference$sum <-  data_difference$sum + data_difference_next[,names[i]]
  }
  # 开方
  data_difference$sum <- data_difference$sum %>% sqrt()
  colnames(data_difference) <- c(newNames, "result")
  return(data_difference)
}
```

calculation:
```{r calculate}
# this calculates the distance.
time_period <- 0.01
processed_curve <- curve_points
processed_curve$time <- (0:(nrow(processed_curve) - 1)) * time_period
# speed
speed_df <- differentiate_df(processed_curve, c("x", "y", "z"), c("vx", "vy", "vz"), time_period)
processed_curve$speed <- speed_df$result
# acceleration
acc_df <- differentiate_df(speed_df, c("vx", "vy", "vz"), c("ax", "ay", "az"), time_period)
processed_curve$acc <- acc_df$result
# jerk
j_df <- differentiate_df(acc_df, c("ax", "ay", "az"), c("jx", "jy", "jz"), time_period)
processed_curve$jerk <- j_df$result
# err
err_df <- differentiate_df(j_df, c("jx", "jy", "jz"), c("ex", "ey", "ez"),  time_period)
processed_curve$err <- err_df$result
```

visualization:
```{r visualization}
ggplot(data = processed_curve[2000:2100,]) +
  geom_path(mapping = aes(x = time, y = speed), colour="#FF0000") #+ 
  #geom_point(mapping = aes(x = time, y = speed), colour="#66ccff")
ggplot(data = processed_curve[2000:2100,]) + 
  geom_path(mapping = aes(x = time, y = acc), colour="#FF0000") + 
  geom_point(mapping = aes(x = time, y = acc), colour="#66ccff")
ggplot(data = processed_curve) + 
  geom_path(mapping = aes(x = time, y = jerk), colour="#FF0000") + 
  geom_point(mapping = aes(x = time, y = jerk), colour="#66ccff")
ggplot(data = processed_curve) + 
  geom_path(mapping = aes(x = time, y = err), colour="#FF0000") + 
  geom_point(mapping = aes(x = time, y = err), colour="#66ccff")
```

## Check errors:
```{r error_checker}
point_line_distance <- function(line_pt1, line_pt2, point){
  a <- line_pt2 - point
  b <- line_pt1 - point
  #print(line_pt1)
  #print(a)
  #print(b)
  clen <- (line_pt2 - line_pt1) %>% sapply(function(v){return(v^2)}) %>% sum %>% sqrt
  #print(clen)
  alen <- a %>% sapply(function(v){return(v^2)}) %>% sum %>% sqrt
  #print(alen)
  blen <- b %>% sapply(function(v){return(v^2)}) %>% sum %>% sqrt
  #print(blen)
  if (alen == 0 || blen == 0){
    return(0)
  } else if (clen == 0) {
    return(alen)
  } else {
    cos <- (a * b) %>% sum / alen / blen
    sin <- (1 - cos^2) %>% abs %>% sqrt %>% as.numeric()
    return(alen * blen * sin / clen)
  }
}

error_checker <- function(refference, exam){
  ref_df <- refference %>% as.matrix()
  exam_df <- exam %>% as.matrix()
  currLineNum <- 1
  error <- runif(nrow(exam_df), 0, 0)
  for (i in 1 : nrow(exam_df)){
    if (currLineNum < nrow(ref_df) - 1){
      pt1 <- ref_df[currLineNum,]
      pt2 <- ref_df[currLineNum + 1,]
      pt3 <- ref_df[currLineNum + 2,]
      exam_pt <- exam_df[i,]
  
      d1 <- point_line_distance(pt1, pt2, exam_pt)
      d2 <- point_line_distance(pt2, pt3, exam_pt)
  
      if (d2 < d1) {
        currLineNum <- min(currLineNum + 1, nrow(ref_df) - 1)
        error[i] <- d2
      } else {
        error[i] <- d1
      }
    
    } else {
      #print(sprintf("final line."))
      pt1 <- ref_df[currLineNum,]
      pt2 <- ref_df[currLineNum + 1,]
      exam_pt <- exam_df[i,]
      error[i] <- point_line_distance(pt1, pt2, exam_pt)
    }
  }
  num <- c(1:nrow(exam_df))
  error_df <- data.frame(num, error)
  return(error_df)
}

error_df <- error_checker(points_pick_reg, curve_points)

ggplot(data = error_df, mapping = aes(x = num, y = error)) + geom_path()
```




## old codes:
checking:
```{r check}
test_curve <- curve_points
test_curve$time <- (0:(nrow(test_curve) - 1)) * time_period
test_curve$distance <- find_dist_from_df(test_curve)
test_curve$speed <- find_speed_from_distance(test_curve$distance, time_period)
test_curve$acceleration <- differential_with_time(test_curve$speed, time_period)
test_curve$jerk <- differential_with_time(test_curve$acceleration, time_period)
test_curve <- test_curve %>% as.data.frame()
ggplot(data = test_curve, mapping = aes(x = time, y = speed)) +
  geom_path() + 
  geom_smooth()
ggplot(data = test_curve, mapping = aes(x = time, y = acceleration)) + 
  geom_path()  +
  geom_smooth() 
ggplot(data = test_curve, mapping = aes(x = time, y = jerk)) + 
  geom_path()  +
  geom_smooth() 
```

```{r }
ggplot() +
  geom_path(data = temp, mapping = aes(x = ))
```